<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxQBDwk3cvr1bt8YVL5m6bJGrFEmzrSbCrH1roypLjJr4AbbteCKh9Y6gQVYexdY85QA2HG5nQFLWpRp69zFSPDJ9" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxoxUgsBRs2yjjBBcfeCc8XigM7erXHmjJg2tjdGxNBxwTYuDonuYswXqRStaCA2b3rTEPCgPwixJmAVrea1qAHHU" rel="stylesheet" type="text/css"><script src="https://storage.googleapis.com/nextjournal-cas-eu/data/8VujAQ3bHzgNYiC3C61DJwUmXP7xW6bB8tT92xAKhDyu5vXReakaHVSrqJfurggZdCJVuAf3B7AujNBvkJAcz974uH" type="text/javascript"></script></head><body><div id="clerk-static-app"></div><script>let viewer = nextjournal.clerk.sci_viewer
let app = nextjournal.clerk.static_app
let docs = viewer.read_string("{\"src/linalg/bench.clj\" {:nextjournal/value [{:nextjournal/value \"(ns linalg.bench\\n  (:require\\n   [criterium.core :refer (quick-bench)]\\n   [nextjournal.clerk :as clerk :refer (code)]\\n   [uncomplicate.neanderthal.core :as unc\\n    :refer (mm mv scal axpy)]\\n   [uncomplicate.neanderthal.native :as unn :refer (dv dge)]\\n   [uncomplicate.neanderthal.random :as random]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(random/rng-state unn/native-float 3)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #object[java.nio.DirectByteBuffer 0x30721404 \\\"java.nio.DirectByteBuffer[pos=0 lim=8 cap=8]\\\"], :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn runif [n]\\n  (into [] (random/rand-uniform! (dv n))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.bench/runif\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn bench [n]\\n  (let [x (runif n)\\n        y (runif n)]\\n    (quick-bench (reduce + (map * x y)))\\n    (quick-bench\\n     (let [x' (dv x)\\n           y' (dv y)]\\n       (unc/dot x' y')))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.bench/bench\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=5$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench 5)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 876738 in 6 samples of 146123 calls.\\\\n             Execution time mean : 691.257151 ns\\\\n    Execution time std-deviation : 7.189292 ns\\\\n   Execution time lower quantile : 686.311580 ns ( 2.5%)\\\\n   Execution time upper quantile : 703.179994 ns (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 440934 in 6 samples of 73489 calls.\\\\n             Execution time mean : 1.994292 µs\\\\n    Execution time std-deviation : 951.845955 ns\\\\n   Execution time lower quantile : 982.223761 ns ( 2.5%)\\\\n   Execution time upper quantile : 2.870548 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=10$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench 10)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 454686 in 6 samples of 75781 calls.\\\\n             Execution time mean : 1.341089 µs\\\\n    Execution time std-deviation : 9.232542 ns\\\\n   Execution time lower quantile : 1.324884 µs ( 2.5%)\\\\n   Execution time upper quantile : 1.349533 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 397128 in 6 samples of 66188 calls.\\\\n             Execution time mean : 2.016048 µs\\\\n    Execution time std-deviation : 880.719634 ns\\\\n   Execution time lower quantile : 1.075957 µs ( 2.5%)\\\\n   Execution time upper quantile : 2.826259 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=20$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench 20)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 232512 in 6 samples of 38752 calls.\\\\n             Execution time mean : 2.588330 µs\\\\n    Execution time std-deviation : 13.910380 ns\\\\n   Execution time lower quantile : 2.561480 µs ( 2.5%)\\\\n   Execution time upper quantile : 2.600116 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 242448 in 6 samples of 40408 calls.\\\\n             Execution time mean : 2.778910 µs\\\\n    Execution time std-deviation : 1.076535 µs\\\\n   Execution time lower quantile : 1.561957 µs ( 2.5%)\\\\n   Execution time upper quantile : 4.338615 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=25$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench 25)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 185940 in 6 samples of 30990 calls.\\\\n             Execution time mean : 3.232253 µs\\\\n    Execution time std-deviation : 18.064851 ns\\\\n   Execution time lower quantile : 3.214360 µs ( 2.5%)\\\\n   Execution time upper quantile : 3.259096 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 305706 in 6 samples of 50951 calls.\\\\n             Execution time mean : 2.744227 µs\\\\n    Execution time std-deviation : 638.499262 ns\\\\n   Execution time lower quantile : 2.027618 µs ( 2.5%)\\\\n   Execution time upper quantile : 3.550405 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=50$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench 50)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 94482 in 6 samples of 15747 calls.\\\\n             Execution time mean : 6.445640 µs\\\\n    Execution time std-deviation : 65.545770 ns\\\\n   Execution time lower quantile : 6.316341 µs ( 2.5%)\\\\n   Execution time upper quantile : 6.492032 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 282918 in 6 samples of 47153 calls.\\\\n             Execution time mean : 4.007234 µs\\\\n    Execution time std-deviation : 1.256133 µs\\\\n   Execution time lower quantile : 3.058932 µs ( 2.5%)\\\\n   Execution time upper quantile : 5.856409 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=100$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench 100)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 47766 in 6 samples of 7961 calls.\\\\n             Execution time mean : 12.734763 µs\\\\n    Execution time std-deviation : 108.883706 ns\\\\n   Execution time lower quantile : 12.651390 µs ( 2.5%)\\\\n   Execution time upper quantile : 12.909432 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 120954 in 6 samples of 20159 calls.\\\\n             Execution time mean : 4.727288 µs\\\\n    Execution time std-deviation : 1.085186 µs\\\\n   Execution time lower quantile : 3.563951 µs ( 2.5%)\\\\n   Execution time upper quantile : 6.372514 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 64.4703 % Variance is severely inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=500$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench 500)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 9546 in 6 samples of 1591 calls.\\\\n             Execution time mean : 71.395879 µs\\\\n    Execution time std-deviation : 10.000432 µs\\\\n   Execution time lower quantile : 63.332505 µs ( 2.5%)\\\\n   Execution time upper quantile : 83.384337 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 28722 in 6 samples of 4787 calls.\\\\n             Execution time mean : 16.822348 µs\\\\n    Execution time std-deviation : 3.882755 µs\\\\n   Execution time lower quantile : 13.399719 µs ( 2.5%)\\\\n   Execution time upper quantile : 21.647527 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn bench-scale\\n  \\\"Benchmark of scaling a vector\\\"\\n  [n]\\n  (let [x (runif n)\\n        alpha (first (runif 1))]\\n    (quick-bench (mapv #(* alpha %) x))\\n    (quick-bench\\n     (let [x' (dv x)]\\n       (into [] (unc/scal! alpha x'))))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.bench/bench-scale\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=5$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-scale 5)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 2452374 in 6 samples of 408729 calls.\\\\n             Execution time mean : 244.095077 ns\\\\n    Execution time std-deviation : 3.713665 ns\\\\n   Execution time lower quantile : 241.528720 ns ( 2.5%)\\\\n   Execution time upper quantile : 250.380027 ns (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 516732 in 6 samples of 86122 calls.\\\\n             Execution time mean : 1.552718 µs\\\\n    Execution time std-deviation : 258.088238 ns\\\\n   Execution time lower quantile : 1.115470 µs ( 2.5%)\\\\n   Execution time upper quantile : 1.840327 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 47.6436 % Variance is moderately inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=50$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-scale 50)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 406542 in 6 samples of 67757 calls.\\\\n             Execution time mean : 1.491661 µs\\\\n    Execution time std-deviation : 26.841464 ns\\\\n   Execution time lower quantile : 1.467972 µs ( 2.5%)\\\\n   Execution time upper quantile : 1.517469 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 178182 in 6 samples of 29697 calls.\\\\n             Execution time mean : 4.656017 µs\\\\n    Execution time std-deviation : 868.689363 ns\\\\n   Execution time lower quantile : 3.509461 µs ( 2.5%)\\\\n   Execution time upper quantile : 5.420679 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=100$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-scale 100)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 205446 in 6 samples of 34241 calls.\\\\n             Execution time mean : 2.943510 µs\\\\n    Execution time std-deviation : 33.788556 ns\\\\n   Execution time lower quantile : 2.911430 µs ( 2.5%)\\\\n   Execution time upper quantile : 2.980541 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 102630 in 6 samples of 17105 calls.\\\\n             Execution time mean : 7.122984 µs\\\\n    Execution time std-deviation : 1.413413 µs\\\\n   Execution time lower quantile : 5.938126 µs ( 2.5%)\\\\n   Execution time upper quantile : 9.393181 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 48.3465 % Variance is moderately inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=200$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-scale 200)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 106116 in 6 samples of 17686 calls.\\\\n             Execution time mean : 5.752707 µs\\\\n    Execution time std-deviation : 147.371416 ns\\\\n   Execution time lower quantile : 5.637232 µs ( 2.5%)\\\\n   Execution time upper quantile : 5.993274 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 56220 in 6 samples of 9370 calls.\\\\n             Execution time mean : 12.209325 µs\\\\n    Execution time std-deviation : 1.822846 µs\\\\n   Execution time lower quantile : 10.947336 µs ( 2.5%)\\\\n   Execution time upper quantile : 15.221378 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 47.0793 % Variance is moderately inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=500$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-scale 500)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 42660 in 6 samples of 7110 calls.\\\\n             Execution time mean : 14.214312 µs\\\\n    Execution time std-deviation : 220.531142 ns\\\\n   Execution time lower quantile : 13.975555 µs ( 2.5%)\\\\n   Execution time upper quantile : 14.459415 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 23658 in 6 samples of 3943 calls.\\\\n             Execution time mean : 27.415571 µs\\\\n    Execution time std-deviation : 1.518547 µs\\\\n   Execution time lower quantile : 25.702383 µs ( 2.5%)\\\\n   Execution time upper quantile : 28.812352 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=10000$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-scale 10000)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 2214 in 6 samples of 369 calls.\\\\n             Execution time mean : 281.098587 µs\\\\n    Execution time std-deviation : 5.761707 µs\\\\n   Execution time lower quantile : 275.073491 µs ( 2.5%)\\\\n   Execution time upper quantile : 289.599479 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 1230 in 6 samples of 205 calls.\\\\n             Execution time mean : 556.915677 µs\\\\n    Execution time std-deviation : 111.737775 µs\\\\n   Execution time lower quantile : 494.608976 µs ( 2.5%)\\\\n   Execution time upper quantile : 746.090287 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 48.3827 % Variance is moderately inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn bench-add\\n  \\\"Benchmark of adding 3 vectors\\\"\\n  [n]\\n  (let [x (runif n)\\n        y (runif n)\\n        z (runif n)]\\n    (quick-bench (mapv + x y z))\\n    (quick-bench\\n     (let [x' (dv x)\\n           y' (dv y)\\n           z' (dv z)]\\n       (into [] (unc/axpy! 1 x' y' z'))))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.bench/bench-add\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=5$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add 5)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 436626 in 6 samples of 72771 calls.\\\\n             Execution time mean : 1.511809 µs\\\\n    Execution time std-deviation : 195.932645 ns\\\\n   Execution time lower quantile : 1.377032 µs ( 2.5%)\\\\n   Execution time upper quantile : 1.771008 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 65004 in 6 samples of 10834 calls.\\\\n             Execution time mean : 3.384872 µs\\\\n    Execution time std-deviation : 3.078781 µs\\\\n   Execution time lower quantile : 2.118171 µs ( 2.5%)\\\\n   Execution time upper quantile : 8.725645 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 83.1147 % Variance is severely inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=20$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add 20)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 132528 in 6 samples of 22088 calls.\\\\n             Execution time mean : 4.577676 µs\\\\n    Execution time std-deviation : 33.854270 ns\\\\n   Execution time lower quantile : 4.525653 µs ( 2.5%)\\\\n   Execution time upper quantile : 4.613594 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 2 outliers in 6 samples (33.3333 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n\\\\tlow-mild\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 183066 in 6 samples of 30511 calls.\\\\n             Execution time mean : 5.866182 µs\\\\n    Execution time std-deviation : 2.119796 µs\\\\n   Execution time lower quantile : 4.605996 µs ( 2.5%)\\\\n   Execution time upper quantile : 9.257827 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 81.9484 % Variance is severely inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=50$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add 50)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 56118 in 6 samples of 9353 calls.\\\\n             Execution time mean : 10.877385 µs\\\\n    Execution time std-deviation : 159.902213 ns\\\\n   Execution time lower quantile : 10.720823 µs ( 2.5%)\\\\n   Execution time upper quantile : 11.105713 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 74046 in 6 samples of 12341 calls.\\\\n             Execution time mean : 7.298203 µs\\\\n    Execution time std-deviation : 964.339885 ns\\\\n   Execution time lower quantile : 5.738377 µs ( 2.5%)\\\\n   Execution time upper quantile : 8.388004 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=200$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add 200)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 14358 in 6 samples of 2393 calls.\\\\n             Execution time mean : 41.888652 µs\\\\n    Execution time std-deviation : 285.170740 ns\\\\n   Execution time lower quantile : 41.603242 µs ( 2.5%)\\\\n   Execution time upper quantile : 42.261702 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 35892 in 6 samples of 5982 calls.\\\\n             Execution time mean : 20.292733 µs\\\\n    Execution time std-deviation : 3.589655 µs\\\\n   Execution time lower quantile : 16.826329 µs ( 2.5%)\\\\n   Execution time upper quantile : 26.022838 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 47.9194 % Variance is moderately inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=500$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add 500)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 5718 in 6 samples of 953 calls.\\\\n             Execution time mean : 105.122200 µs\\\\n    Execution time std-deviation : 1.086799 µs\\\\n   Execution time lower quantile : 103.452078 µs ( 2.5%)\\\\n   Execution time upper quantile : 106.072006 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 15678 in 6 samples of 2613 calls.\\\\n             Execution time mean : 43.781786 µs\\\\n    Execution time std-deviation : 4.424639 µs\\\\n   Execution time lower quantile : 39.954617 µs ( 2.5%)\\\\n   Execution time upper quantile : 49.981165 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=1000$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add 1000)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 2868 in 6 samples of 478 calls.\\\\n             Execution time mean : 210.781598 µs\\\\n    Execution time std-deviation : 2.203965 µs\\\\n   Execution time lower quantile : 207.886477 µs ( 2.5%)\\\\n   Execution time upper quantile : 213.354690 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 8040 in 6 samples of 1340 calls.\\\\n             Execution time mean : 81.622232 µs\\\\n    Execution time std-deviation : 7.833883 µs\\\\n   Execution time lower quantile : 76.293473 µs ( 2.5%)\\\\n   Execution time upper quantile : 91.864827 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=10,000$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add 10000)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 288 in 6 samples of 48 calls.\\\\n             Execution time mean : 2.130532 ms\\\\n    Execution time std-deviation : 29.656373 µs\\\\n   Execution time lower quantile : 2.092024 ms ( 2.5%)\\\\n   Execution time upper quantile : 2.165761 ms (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 2 outliers in 6 samples (33.3333 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n\\\\tlow-mild\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 804 in 6 samples of 134 calls.\\\\n             Execution time mean : 839.348128 µs\\\\n    Execution time std-deviation : 105.335884 µs\\\\n   Execution time lower quantile : 756.986269 µs ( 2.5%)\\\\n   Execution time upper quantile : 1.012494 ms (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 31.4961 % Variance is moderately inflated by outliers\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn bench-add-no-io\\n  \\\"Benchmark of scaling a vector\\\"\\n  [n]\\n  (let [x (runif n)\\n        y (runif n)\\n        z (runif n)\\n        x' (dv x)\\n        y' (dv y)\\n        z' (dv z)]\\n    (quick-bench (mapv + x y z))\\n    (quick-bench (unc/axpy! 1 x' y' z'))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.bench/bench-add-no-io\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=5$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add-no-io 5)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 419928 in 6 samples of 69988 calls.\\\\n             Execution time mean : 1.443451 µs\\\\n    Execution time std-deviation : 8.305840 ns\\\\n   Execution time lower quantile : 1.433192 µs ( 2.5%)\\\\n   Execution time upper quantile : 1.453611 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 3303972 in 6 samples of 550662 calls.\\\\n             Execution time mean : 179.918012 ns\\\\n    Execution time std-deviation : 3.702570 ns\\\\n   Execution time lower quantile : 175.249748 ns ( 2.5%)\\\\n   Execution time upper quantile : 183.135829 ns (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=20$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add-no-io 20)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 130026 in 6 samples of 21671 calls.\\\\n             Execution time mean : 4.634886 µs\\\\n    Execution time std-deviation : 48.620246 ns\\\\n   Execution time lower quantile : 4.550864 µs ( 2.5%)\\\\n   Execution time upper quantile : 4.674281 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 3101664 in 6 samples of 516944 calls.\\\\n             Execution time mean : 183.843437 ns\\\\n    Execution time std-deviation : 3.307902 ns\\\\n   Execution time lower quantile : 179.768563 ns ( 2.5%)\\\\n   Execution time upper quantile : 186.585920 ns (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=10,000$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add-no-io 10000)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 288 in 6 samples of 48 calls.\\\\n             Execution time mean : 2.155784 ms\\\\n    Execution time std-deviation : 10.601848 µs\\\\n   Execution time lower quantile : 2.142197 ms ( 2.5%)\\\\n   Execution time upper quantile : 2.167248 ms (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\nEvaluation count : 132396 in 6 samples of 22066 calls.\\\\n             Execution time mean : 4.597382 µs\\\\n    Execution time std-deviation : 25.752032 ns\\\\n   Execution time lower quantile : 4.571661 µs ( 2.5%)\\\\n   Execution time upper quantile : 4.630929 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $n=20,000$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(code (with-out-str (bench-add-no-io 20000)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 144 in 6 samples of 24 calls.\\\\n             Execution time mean : 4.291838 ms\\\\n    Execution time std-deviation : 47.744593 µs\\\\n   Execution time lower quantile : 4.199040 ms ( 2.5%)\\\\n   Execution time upper quantile : 4.332423 ms (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 1 outliers in 6 samples (16.6667 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 109662 in 6 samples of 18277 calls.\\\\n             Execution time mean : 5.606242 µs\\\\n    Execution time std-deviation : 67.654014 ns\\\\n   Execution time lower quantile : 5.547697 µs ( 2.5%)\\\\n   Execution time upper quantile : 5.679693 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(code\\n (with-out-str\\n   (let [v (dv 1000) ]\\n     (quick-bench (last (seq v)))\\n     (quick-bench (peek (into [] v))))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"Evaluation count : 14190 in 6 samples of 2365 calls.\\\\n             Execution time mean : 42.789045 µs\\\\n    Execution time std-deviation : 209.717746 ns\\\\n   Execution time lower quantile : 42.502862 µs ( 2.5%)\\\\n   Execution time upper quantile : 43.024439 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\\nFound 2 outliers in 6 samples (33.3333 %)\\\\n\\\\tlow-severe\\\\t 1 (16.6667 %)\\\\n\\\\tlow-mild\\\\t 1 (16.6667 %)\\\\n Variance from outliers : 13.8889 % Variance is moderately inflated by outliers\\\\nEvaluation count : 16560 in 6 samples of 2760 calls.\\\\n             Execution time mean : 39.385971 µs\\\\n    Execution time std-deviation : 2.703605 µs\\\\n   Execution time lower quantile : 36.986557 µs ( 2.5%)\\\\n   Execution time upper quantile : 42.804872 µs (97.5%)\\\\n                   Overhead used : 4.348706 ns\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(comment\\n  (clerk/show! \\\"src/linalg/bench.clj\\\")\\n  (tap> \\\"hello\\\")\\n  )\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :linalg.bench}}, \"src/linalg/intro.clj\" {:nextjournal/value [{:nextjournal/value \"(ns linalg.intro\\n  (:require\\n   [nextjournal.clerk :as clerk]\\n   [uncomplicate.neanderthal.core :as unc]\\n   [uncomplicate.neanderthal.native :as unn]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Goals\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"  - Introduce heuristically basic concepts of linear algebra to neophytes with\\n    Clojure knowledge.\\n  - Numerical Linear Algebra is the field concerned with the numerical\\n    application of linear algebra.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Caveat: I will consciously ignore a few mathematical details, to emphasize on\\n the intuition [this hurts me as a mathematician].\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" We will cover:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Linear Vector Spaces in Finite Dimension\\n - Linear Mappings\\n - Matrix\\n - Eigenvalues\\n - Special matrices\\n - Neanderthal API.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Numerical linear algebra should be a topic by itself, and hence left out for\\n this presentation.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" # What is Linear Algebra?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Intuitively, we want to:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   - extend our understanding of geometry in 2D and 3D to higher dimensions\\n   - generalize notions such as distance and isomorphism\\n   - explore if there exist special structures or transformation\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Crudely speaking and for a software engineer, linear algebra is the science and\\n art of adding and multiplying numbers fast without a user-defined loop.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" For mathematicians, these are the questions of interest (extend to an arbitrary\\n finite integer number $n$):\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Addition:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\vec v + \\\\vec w = \\\\begin{bmatrix}\\n       v_{1} & v_{2} & v_{3} \\\\\\\\\\n \\\\end{bmatrix}\\n +\\n \\\\begin{bmatrix}\\n       w_{1} & w_{2} & w_{3}\\\\\\\\\\n \\\\end{bmatrix}\\n     =\\n \\\\begin{bmatrix}\\n       v_{1} + w_{1} & v_{2} + w_{2} & v_{3} + w_{3}\\n \\\\end{bmatrix} $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The computational complexity is $O(n)$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Scaling:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\alpha \\\\vec v = \\\\alpha\\n \\\\begin{bmatrix}\\n       v_{1} & v_{2} & v_{3}\\n \\\\end{bmatrix}\\n =\\n \\\\begin{bmatrix}\\n       \\\\alpha v_{1} & \\\\alpha v_{2} & \\\\alpha v_{3}\\n \\\\end{bmatrix} $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" It also has $O(n)$ computational complexity.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Matrix multiplication:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ AB = \\\\begin{bmatrix}\\n       a_{11} & a_{12} & a_{13} \\\\\\\\\\n       a_{21} & a_{22} & a_{23} \\\\\\\\\\n       a_{31} & a_{32} & a_{33} \\\\\\\\\\n       a_{41} & a_{42} & a_{43}\\n \\\\end{bmatrix}\\n \\\\cdot\\n \\\\begin{bmatrix}\\n       b_{11} & b_{21} \\\\\\\\\\n       b_{21} & b_{22} \\\\\\\\\\n       b_{31} & b_{32}\\n \\\\end{bmatrix}\\n     =\\n \\\\begin{bmatrix}\\n       r_{11} & r_{12} \\\\\\\\\\n       r_{21} & r_{22} \\\\\\\\\\n       r_{31} & r_{32} \\\\\\\\\\n       r_{41} & r_{42}\\n \\\\end{bmatrix} = R$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ r_{ij} = \\\\sum_{k} a_{ik}b_{kj} $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The computational complexity of $O(nmp)$ speed, $n$ count of rows for the first\\n matrix, $m$ count of the rows for the second matrix, $p$ number of columns\\n of the second matrix.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" When the second matrix is a single column, we have $O(n^2)$ complexity algorithm,\\n and when both matrices have the number of rows and columns $O(n^3)$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" In code, we want to compute the following operations as fast as possible:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def v [0 1 2 3])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def w [3 2 -1 0])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value -1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def a 3)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(mapv + v w)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" [3 3 1 3]\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(mapv (partial * a)  v)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" [0 3 6 9]\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def X [[1 1 1 1]\\n        [2 2 2 2]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(mapv #(reduce + (map * % v)) X)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" [6 12]\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(mapv #(mapv (fn [x] (reduce + (map * % x))) [v w]) X)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" [[6 4]\\n  [12 8]]\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Mathematically speaking, linear algebra studies vector spaces and linear\\n transformations between vector spaces (sets of things with some structures).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The question that we can ask ourselves:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - How can we interpret the vector and the matrices? (vector spaces, and linear\\n   transformation).\\n - In a matrix, are all the rows/columns containing additional information? (rank).\\n - Is there a more efficient representation of the matrices?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" # Why Should We Care about Linear Algebra?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" These are examples of areas where linear algebra is applied:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Statistics: linear algebra provides a vocabulary and\\n   tools to solve problems in high dimensions.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Machine Learning: linear algebra is abused for computer vision, natural\\n   language processing, speech recognition, and gaming agent.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Simulations of [stochastic] systems (Markov chains): when studying systems\\n   where variables can influence each other, linear algebra might help to find\\n   the equilibrium state.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Study of graphs/networks: graphs and networks can be represented as a matrix\\n   where each row represents the outward connection from a vertex to another\\n   vertex.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Other examples: solving linear equations, solving partial differential\\n   equations, optimization and budgeting, computer graphics.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" # Why Learn a Specialized Linear Algebra Library?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" One could heuristically define most linear algebra operations as such\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def plus #(apply mapv + %&))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.intro/plus\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn times [alpha x] (mapv (partial * alpha) x))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.intro/times\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn dot [x y] (reduce + (mapv * x y)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.intro/dot\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Suppose matrix are row majors\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn transpose [Y] (apply mapv vector Y))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.intro/transpose\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn %*% [X Y]\\n  (mapv (fn [x] (mapv #(dot x %) (transpose Y))) X))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.intro/%*%\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(plus [1 2] [0 1])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(times 3 [1 2])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(dot [1 2] [0 1])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(%*% [[1 0] [0 1]]\\n     [[1 2] [3 4]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(%*% [[0 1] [1 0]]\\n     [[1 2] [3 4]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(%*% [[-1 0] [0 1]]\\n     [[1 2] [3 4]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value -1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value -2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Speed and Algorithms\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The reason linear algebra is a necessity in practice for these fields is thanks\\n to the concept and the hardware implementation of *single instruction multiple\\n data* (`SIMD`), in other words, the art of applying the same operation to\\n multiple data points. CPU and GPU have specialized instructions to perform\\n linear algebra operations, speeding them up by a magnitude of orders\\n (depending on the size of the problem).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The gain speed allowed for the creation of algorithms (such as the bootstrap in\\n statistics).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Depending on the structure of your problem, you could leverage the shape of\\n your matrices to speed up, even more, the computations.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" # Linear Algebra Concepts\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Vector Spaces Example:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Take two vectors of numbers and a scalar say\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def v [0 1 2 3])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def w [3 2 -1 0])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value -1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def a 3)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Then, intuitively the addition and the scaling operation are\\n defined as element-wise operations:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(mapv + v w)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(mapv (partial * a)  v)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" We can try to abstract this behavior, this would lead to the proper definition\\n of a vector space in mathematics.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Vector Spaces: Definition\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A vector space, a set of elements, is a set stable under a `+` operation and a\\n `*` scalar operation, with the following property, for all $u, v, w \\\\in V$:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Commutativity: $u+v = v+u$\\n - Associativity: $(u + v) + w = u (v + w)$ and $(ab)v = a(bv)$.\\n - Additive identity: there exists $0 \\\\in V$ such that $v+0 = v$.\\n - Additive inverse: for all $v \\\\in V$, there exist $w \\\\in W$ such that $v+w =\\n   0$.\\n - Multiplicative identity ($1v=v$, for all $v \\\\in V$),\\n - Distributive properties: $(\\\\alpha+\\\\beta)(u+v) = \\\\alpha u + \\\\alpha u + \\\\beta v + \\\\beta v$, for all $\\\\alpha, \\\\beta \\\\in \\\\mathcal{F}$, and $v, w \\\\in V$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The most used vector space is probably the cartesian product of $\\\\mathbb{R}$,\\n that is $\\\\mathbb{R} \\\\times \\\\mathbb{R} = \\\\mathbb{R}^2$, and generally\\n $\\\\mathbb{R}^n$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Other vector spaces: the space of function from $\\\\mathbb{R}$ to\\n $\\\\mathbb{R}$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ### Distance and Angle: Inner Product Space & Norm\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" An inner product on $V$ is a function taking each ordered pair $(u, v)$ of\\n elements in $V$ to a number $\\\\langle u, v \\\\rangle$ \\\\in $\\\\mathbb{F}$ with the\\n following properties:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Positivity $\\\\langle v, v \\\\rangle \\\\geq 0$ for all $v \\\\in V$.\\n - Definiteness $\\\\langle v, v \\\\rangle = 0$ if and only if $v = 0$;\\n - Additivity and homogeneity in the first slot: for all $u, v, w \\\\in V$ and\\n   $\\\\lambda \\\\in \\\\mathbb{F}$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   $$\\\\langle \\\\lambda u + v, w \\\\rangle = \\\\lambda \\\\langle u, w \\\\rangle + \\\\langle v, w \\\\rangle$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Conjugate symmetry: $\\\\langle u, v \\\\rangle$ is the conjugate of $\\\\langle v, u\\n   \\\\rangle$ (when $\\\\mathbb{F} = \\\\mathbb{R}, they are equal).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" In most applications, the inner product of two vectors is the euclidean dot\\n product $\\\\langle v, w \\\\rangle = \\\\sum_i v_i w_i$, which translate to\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn dot [v w] (reduce + (map * v w)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.intro/dot\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Usually, one uses the notation $v^\\\\top w$ for the euclidean product instead of\\n $\\\\langle v, w \\\\rangle$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Thanks to the inner product, we can generalize the notion of *length* $\\\\| v \\\\|$ (we call\\n it a *norm*) for a vector $v$ as\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$\\\\| v \\\\| = \\\\sqrt{\\\\langle v, v \\\\rangle}.$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" This norm then define the *distance* between two vectors $v$ and $w$ as the\\n norm of their difference:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$\\\\| v - w \\\\| = \\\\sqrt{\\\\langle v-w, v-w \\\\rangle}.$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ### Subspaces\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Let's take the space $V=\\\\mathbb{R}^3$ as an example.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" We can define regions (in $\\\\mathbb{R}^3$ they will be lines or plane surface) in the\\n space that are strictly smaller than $V$ but would remain subvector\\n space. For example,\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$\\\\{ \\\\lambda (1, 0): \\\\lambda \\\\in \\\\mathbb{R}\\\\}$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$\\\\{ \\\\lambda (1, 0) + \\\\mu (0, 1): \\\\lambda, \\\\mu \\\\in \\\\mathbb{R}\\\\}$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Formally a subvector space is a subset of $V$ (possibly equal to $V$) which is\\n also a vector space. Common examples of subvector space are projections.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Linear Independence, Basis and Dimension\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" We say a list $v_1, \\\\dots, v_n$ is *linearly independent* if $\\\\sum_{i=1}^n \\\\alpha_i v_i = 0$,\\n implies all $\\\\alpha_i$ are equal to 0. Basically, it means all the\\n vectors contains some information.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" We say a vector space $V$ is in the span $v_1, \\\\dots, v_n$ if any element in\\n $V$ can be represented as a linear representation of $v_1, \\\\dots, v_n$. That is\\n for all $v \\\\in V$, there exist a list of $\\\\alpha_1, \\\\dots, \\\\alpha_n$ such that\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$v = \\\\sum_{i=1}^n \\\\alpha_i v_i$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" We say the list is a basis of $V$ if it is linearly independent.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Finally, one defines the dimension of $V$ as the number of elements in any basis\\n of $V$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ### Orthonormal basis\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A list $(e_1, \\\\dots, e_n)$ of vectors in $V$ is *orthonormal* if\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\langle e_j, e_k \\\\rangle = \\\\mathbb{1}(j=k) \\\\textrm{ for all } j,k=1, \\\\dots, n. $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Intuitively, the vector $e_j$ are *perpendicular* to each other and have a\\n *norm* or *length* of 1. There might exist an infinite amount of orthonormal\\n bases for a given space, but their count is always the same.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The most widely used orthonormal basis is the canonical basis $e_1, \\\\dots, e_n$,\\n where each vector $e_j$ contains only 0, except at position\\n $j$, where the number is $1$. For example in $\\\\mathbb{R}^3$,\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ e_1  = \\\\begin{bmatrix} 1 & 0 & 0 \\\\end{bmatrix}, \\\\quad e_2 = \\\\begin{bmatrix} 0 & 1 & 0\\\\end{bmatrix}, \\\\quad e_3 = \\\\begin{bmatrix} 0 & 0 & 1\\\\end{bmatrix} $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" # Linear Mappings and Matrices\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A *linear map* from a space $V$ to another vector space $W$ is a function $T: V\\n \\\\to W,$ such that for all $u, v \\\\in V, \\\\lambda \\\\in \\\\mathcal{F}$ one has\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ T(\\\\lambda v + w) = \\\\lambda T(v) + T(w). $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" One such example in $\\\\mathbb{R}^2$: the mapping the switch the sign of the\\n second component:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ T(\\\\begin{bmatrix} v_1 & v_2 \\\\end{bmatrix}) = \\\\begin{bmatrix} v_1 & -v_2 \\\\end{bmatrix} $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Another example of mapping: the derivative of a function in the space of\\n functions that can be derived is a linear operation, as\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$T(\\\\alpha f+ \\\\beta g) = (\\\\alpha f + \\\\beta g)' = \\\\alpha f' + \\\\beta g' = \\\\alpha\\n T(f) + \\\\beta T(g).$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The space of linear maps from $V \\\\to W$ is also a vector space! In other words, if $S$\\n and $T$ are linear map from $V \\\\to W$, $\\\\lambda \\\\in \\\\mathbb{F}$ then $\\\\lambda S+T$\\n defined as\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ (\\\\lambda S+T)(u) = \\\\lambda S(u) + T(u) $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" is also a linear map from $V \\\\to W$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Composition of linear maps\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" We can chain linear map, if the space are coinciding: if $T: U \\\\to V$, $S: V \\\\to W$,\\n then the product $ST: U \\\\to W$ defined as $(ST)(u) = S(T(u))$ is a\\n linear map from $U \\\\to W$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Matrices\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" But why is all of this useful for understanding matrices?!\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - The space of linear maps and the space matrices are bijective, that is, we can\\n   represent every linear map as a matrice and inversely.\\n - The space of matrices are vector spaces.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A $m \\\\times n$ matrix with $m$ rows and $n$ columns is a rectangular array of number:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ A = \\\\begin{bmatrix} a_{11} & \\\\cdots & a_{1n} \\\\\\\\  \\\\vdots & & \\\\vdots \\\\\\\\ a_{m1} & \\\\cdots & a_{mn}\\\\end{bmatrix}$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Matrice of a linear map\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Let $T: V \\\\to W$, $(v_1, \\\\dots, v_n)$, resp. $(w_1, \\\\dots, w_m)$, be a basis\\n for $V$, resp. $W$. Then, we can compute for every $v_j$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ T(v_j) = a_{1j} w_1 + \\\\dots + a_{mj} w_m $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The $m \\\\times n$ matrix $\\\\mathcal{M}(T)$ of a linear transformation $T$ is then\\n defined as\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\mathcal{M}(T) = \\\\begin{bmatrix} a_{11} & \\\\cdots & a_{1n} \\\\\\\\ \\\\vdots & &\\n \\\\vdots \\\\\\\\ a_{m1} & \\\\cdots & a_{mn}\\\\end{bmatrix} $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Noteworthy:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - It is easier to interpret the matrix columnwise: the coefficient from a\\n   column $j$ is the coefficient of the linear combination to express $w=T(v_j)$\\n   in the basis of $w_1, \\\\dots, w_m$.\\n - The relation is bijective: for every matrix $A$, there exist a linear mapping\\n   $T_A$ from $\\\\mathbb{R}^n$ to $\\\\mathbb{R}^m$, such that $T_A(v_j) = \\\\sum_i\\n   \\\\alpha_{ij} w_i$.\\n - With this connection, the space of matrices is also a vector space! One\\n   defines the addition of matrices as element-wise addition. That is for two\\n   matrices $A,B$ and a coefficient $\\\\lambda$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   $$ (\\\\lambda A + B)_{ij} = \\\\lambda a_{ij} + b_{ij},$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   since we could associate $\\\\lambda A + B$ to the mapping $T_{\\\\lambda A + B}.$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Matrix of a composition and the Product of Matrices\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   Remember we defined the composition $(S_AT_B): U \\\\to W$ of\\n   $S_A: U \\\\to V$ and $T_B: V \\\\to W$ as $(S_AT_B)(u) = S_A(T_B(u))$. Let $(u_1, \\\\dots, u_n)$\\n   , $(v_1 \\\\dots, v_p)$, $(w_1, \\\\dots, w_m)$ be basis of $U$, $V$,\\n   resp. $W$, and $A=\\\\mathcal{M}(S_A)$, $B=\\\\mathcal{M}(T_B)$. Then for every $u_j$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   $$\\n   \\\\begin{aligned} S(T(u_j)) & = S\\\\left(\\\\sum_{l=1}^p b_{lj} v_l\\\\right) \\\\\\\\\\n    & = \\\\sum_{l=1}^p b_{lj} S(v_l) \\\\\\\\\\n    & = \\\\sum_{l=1}^p b_{lj} \\\\sum_{i=1}^m a_{il} w_i\\\\\\\\\\n    & = \\\\sum_{i=1}^m \\\\left(\\\\sum_{l=1}^p  a_{il} b_{lj}\\\\right) w_i \\\\\\\\\\n    & = \\\\left(\\\\sum_{l=1}^p  a_{1l} b_{lj}\\\\right) w_1 + \\\\dots + \\\\left(\\\\sum_{l=1}^p  a_{ml} b_{lj}\\\\right) w_m\\n   \\\\end{aligned}\\n   $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   As such, the element $(i,j)$ of the matrix of the $S_AT_B$ is given by\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   $$ (ST)_{ij} =  \\\\sum_{l=1}^p a_{il} b_{lj}.$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   Since we have a one-to-one relationship with the space of matrices, we could\\n   define a new operation: the matrix multiplication. Hence for a matrix\\n   $A$ and $B$, such that the count of columns of $A$ matches the count of rows\\n   in $B$, we define the matrix multiplication as $C = AB$ such that\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   $$ c_{ij} = \\\\sum_{l=1}^p a_{il} b_{lj}.$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"   Note that the dimensions must match, and that the operation is not\\n   commutative in general ($AB \\\\neq BA$).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Example\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Rotation in the plan is also a linear map (a fact that is quite used in\\n computer vision). Its corresponding matrix in a canonical basis is given by\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\begin{bmatrix}\\n \\\\cos(\\\\theta) & -\\\\sin(\\\\theta)\\\\\\\\\\n \\\\sin(\\\\theta) & \\\\cos(\\\\theta)\\\\\\\\\\n \\\\end{bmatrix}\\n $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" where $\\\\theta$ describes the rotation of the points. Interestingly, shifting\\n points in $\\\\mathbb{R}^2$ can't be described in $\\\\mathbb{R}^2$ but could in\\n $\\\\mathbb{R}^3$ with the following matrices:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ![Affine Transformation as a Linear Map](https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/2D_affine_transformation_matrix.svg/1920px-2D_affine_transformation_matrix.svg.png)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Special matrices structures\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Diagonal matrices: all the elements of the matrices are 0, except those on the diagonal. Example:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\begin{pmatrix}\\n     3 & 0 \\\\\\\\\\n     0 & 2\\n     \\\\end{pmatrix}$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Block/Band diagonal matrices:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\begin{pmatrix}\\n     A & & *\\\\\\\\\\n     &B\\\\\\\\\\n     * &&C\\\\\\\\ \\\\end{pmatrix}$$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" where $A, B, C$ are square matrices. $*$ inside matrices are the notation for\\n saying the elements are equal to 0.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Upper and Lower Triangular Matrices: all elements below or above the diagonal\\n are equal to 0. Example:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\begin{pmatrix} 3 & 3 & 1 \\\\\\\\  & 2 & 0 \\\\\\\\ * &  & 2 \\\\end{pmatrix} $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Symmetric matrices: $A=A^\\\\top$ (the transpose $A^\\\\top$ of the matrice $A$ is\\n   defined as $a_{ij} = a_{ji}^\\\\top$).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Each of these structures allows for calculation optimization. Thus our\\n challenges is often to express the problem at hand in these forms.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" <!-- ## Least Square -->\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" <!-- Small trick: Neanderthal API and Machine Learning/Statistic notations do not -->\\n <!-- coincide. In the latter, the design matrix and regression parameters are -->\\n <!-- denoted with $X$ and $\\\\beta$. In contrast Neanderthal uses $A$ and $x$. -->\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" # Eigenvalues and Eigenvectors\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Let $T: V \\\\to V$ be a linear map. In order to save computation, can we ask if\\n there exists strict subspaces of $V$ where $T$ would be invariant, that is\\n $T(v) = \\\\lambda v$, for some $\\\\lambda \\\\neq 0$ and $v \\\\neq \\\\vec 0$. If such\\n $\\\\lambda$ exists, we call it a eigenvalue, and the associated $v$ a\\n eigenvectors. Note, we usually take the convention that $\\\\| v \\\\| = 1$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The eigenvectors are important as they describe an invariant space, such as if\\n $v_1, v_2$ are eigenvectors with respective eigenvalues $\\\\lambda_1, \\\\lambda_2$,\\n then if $v \\\\in \\\\textrm{span}(v_1, v_2)$, then\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $$ \\\\begin{aligned}\\n   T(v) & = T(\\\\alpha_1 v_1 + \\\\alpha_2 v2) = \\\\alpha_1 T(v_1) + \\\\alpha_2 T(v_2) \\\\\\\\\\n        & = \\\\alpha_1 \\\\lambda_1 v_1 + \\\\alpha_2 \\\\lambda_2 v_2 \\\\in \\\\textrm{span}(v_1, v_2)\\n  \\\\end{aligned}\\n $$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Eigenvectors allow for understanding the linear map more easily. They are the\\n directions along which the linear map is just *dilatation/compression*, and/or\\n *flipping*, eigenvalues are the factors of compression. The more directions,\\n the better the understanding. It allows for decoupling the behavior of each\\n rows with each other.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" # Neanderthal API\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" One can apply all the previous topics to any linear algebra library, we are\\n now going to dig into the main concepts of Neanderthal's API.  In essence, it\\n follows [LAPACK](https://en.wikipedia.org/wiki/LAPACK) naming convention.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Construction of Matrices Vector\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" There are three dimensions for understanding the API:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Numbers type: (`d`ouble, `f`loat (single precision), `i`nteger)\\n - Matrices structure: `v` (vector), `ge` (general/dense matrices), `sy` (symmetric),\\n   `tr` (triangular).\\n - Runtime (Native `uncomplicate.neanderthal.native`, CUDA `uncomplicate.neanderthal.cuda`,\\n   OpenCL `uncomplicate.neanderthal.opencl`).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Hence to create a double general/dense matrix using native (Intel MKL), we\\n would need to call `uncomplicate.neanderthal.native/dge`, similarly for a\\n double vector `uncomplicate.neanderthal.native/dv`.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Functions on Matrices\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Basic operations (altering variables, and many basic linear algebra\\n   operations) are exposed in `uncomplicate.neanderthal.core`.\\n - Advanced math operations on matrices and vectors are exposed in\\n   `uncomplicate.neanderthal.vect-math`.\\n - Linear Algebra Algorithms (`uncomplicate.neanderthal.linalg`): finding eigenvalue,\\n   solving, least squares, matrices decomposition.\\n - Pure against Destructive API: functions finishing with a bang `!` will mutate\\n   their argument and save time and possibly speed up the computation.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" # Main Takeaways\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Linear algebra is the study of linear relationships (addition and scaling) in\\n   arbitrary finite dimensions.\\n - Adding and subtracting matrices and vectors are $O(n)$ operations.\\n - Multiplying a vector with a matrix is a $O(n^2)$.\\n - Multiplying matrices (composing linear maps) is $O(n^3)$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - Vector spaces are mainly generalization of our intuition of geometry in 2D\\n   and 3D, where we only consider addition and scaling.\\n - Vector spaces are spanned by a basis, a list of linearly independent vectors.\\n - Linear maps are transformation that preserves the additive and homogeneity\\n   between the domain and image space.\\n - Linear maps can be described by the coefficient of the image of the basis of\\n   the input space.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - There exists a one-to-one relationship between the space of linear maps and the\\n   space matrices. Hence matrices represent linear transformation.\\n - For a given linear map, there might exist a basis more appropriate\\n   to perform the transformation.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - There are special matrices, which could accelerate your computation.\\n - Eigenvectors of a linear map describe invariant spaces of the mapping.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" - To get the best performance of Neandterhal, you should keep the data\\n   structure in Neandterhal's vectors/matrices. Avoid converting data between\\n   Clojure and Neandterhal memory layout.\\n\", :nextjournal/viewer :markdown}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :linalg.intro}}, \"src/linalg/neanderthal.clj\" {:nextjournal/value [{:nextjournal/value \"(ns linalg.neanderthal\\n  (:require\\n   [nextjournal.clerk :as clerk]\\n   [uncomplicate.neanderthal.core :as unc :refer (axpy mm scal mv)]\\n   [uncomplicate.neanderthal.linalg :as unl]\\n   [uncomplicate.neanderthal.math :as unm :refer (cos sin)]\\n   [uncomplicate.neanderthal.native :as unn :refer (dv dge)]\\n   [uncomplicate.neanderthal.random :as unr]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def cc clerk/code)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"nextjournal.clerk.viewer/code\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn ->vec [x] (into [] x))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.neanderthal/->vec\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn ->vvec [x] (mapv ->vec x))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.neanderthal/->vvec\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn ->plotly [v & ws]\\n  {:data\\n   (into\\n    [{:x [0 (first v)] :y [0 (second v)]\\n      :name :original}]\\n    (map #(-> {:x [0 (first %)] :y [0 (second %)]}))\\n    ws)\\n   :layout {:width 820\\n            :height 600\\n            :legend {:orientation :h}}})\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.neanderthal/->plotly\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Create a vector\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def x (dv 1 2 3))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #RealBlockVector[double, n:3, offset: 0, stride:1]\\n[   1.00    2.00    3.00 ]\\n, :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def xs [(dv [1 2 3]) (dv 1 2 3) (dv 3)])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value #RealBlockVector[double, n:3, offset: 0, stride:1]\\n[   1.00    2.00    3.00 ]\\n, :nextjournal/viewer nil} {:path [1], :nextjournal/value #RealBlockVector[double, n:3, offset: 0, stride:1]\\n[   1.00    2.00    3.00 ]\\n, :nextjournal/viewer nil} {:path [2], :nextjournal/value #RealBlockVector[double, n:3, offset: 0, stride:1]\\n[   0.00    0.00    0.00 ]\\n, :nextjournal/viewer nil}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(cc\\n \\\"[\\n#RealBlockVector[double, n:3, offset: 0, stride:1]\\n  [   1.00    2.00    3.00 ]\\n#RealBlockVector[double, n:3, offset: 0, stride:1]\\n  [   1.00    2.00    3.00 ]\\n#RealBlockVector[double, n:3, offset: 0, stride:1]\\n  [   0.00    0.00    0.00 ]\\n]\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"[\\\\n#RealBlockVector[double, n:3, offset: 0, stride:1]\\\\n  [   1.00    2.00    3.00 ]\\\\n#RealBlockVector[double, n:3, offset: 0, stride:1]\\\\n  [   1.00    2.00    3.00 ]\\\\n#RealBlockVector[double, n:3, offset: 0, stride:1]\\\\n  [   0.00    0.00    0.00 ]\\\\n]\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Create a random vector\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn rand-vec [n]\\n  (let [x (unr/rand-uniform! (dv n))]\\n    (unc/scal (/ 1 (unc/nrm2 x)) x)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.neanderthal/rand-vec\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Create a random 3x2 matrix\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def z (unr/rand-uniform! (dge 3 2)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #RealGEMatrix[double, mxn:3x2, layout:column, offset:0]\\n   ▥       ↓       ↓       ┓    \\n   →       0.74    0.13         \\n   →       0.07    0.87         \\n   →       0.37    0.91         \\n   ┗                       ┛    \\n, :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Column Major\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def z-2 [(dge 3 2 [1 2 3 4 5 6])\\n          (dge 3 2 [[1 2 3] [4 5 6]])])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value #RealGEMatrix[double, mxn:3x2, layout:column, offset:0]\\n   ▥       ↓       ↓       ┓    \\n   →       1.00    4.00         \\n   →       2.00    5.00         \\n   →       3.00    6.00         \\n   ┗                       ┛    \\n, :nextjournal/viewer nil} {:path [1], :nextjournal/value #RealGEMatrix[double, mxn:3x2, layout:column, offset:0]\\n   ▥       ↓       ↓       ┓    \\n   →       1.00    4.00         \\n   →       2.00    5.00         \\n   →       3.00    6.00         \\n   ┗                       ┛    \\n, :nextjournal/viewer nil}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Slicing data\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(cc\\n (let [z (dge 3 2 [1 2 3 4 5 6])]\\n   {:z z\\n    :col-0 (unc/col z 0)\\n    :col-1 (unc/col z 1)\\n    :cols (vec (unc/cols z))\\n    :row-0 (unc/row z 0)\\n    :row-1 (unc/row z 1)\\n    :rows (vec (unc/rows z))}))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"{:z #RealGEMatrix[double, mxn:3x2, layout:column, offset:0]\\\\n   ▥       ↓       ↓       ┓    \\\\n   →       1.00    4.00         \\\\n   →       2.00    5.00         \\\\n   →       3.00    6.00         \\\\n   ┗                       ┛    \\\\n, :col-0 #RealBlockVector[double, n:3, offset: 0, stride:1]\\\\n[   1.00    2.00    3.00 ]\\\\n, :col-1 #RealBlockVector[double, n:3, offset: 3, stride:1]\\\\n[   4.00    5.00    6.00 ]\\\\n, :cols [#RealBlockVector[double, n:3, offset: 0, stride:1]\\\\n[   1.00    2.00    3.00 ]\\\\n #RealBlockVector[double, n:3, offset: 3, stride:1]\\\\n[   4.00    5.00    6.00 ]\\\\n], :row-0 #RealBlockVector[double, n:2, offset: 0, stride:3]\\\\n[   1.00    4.00 ]\\\\n, :row-1 #RealBlockVector[double, n:2, offset: 1, stride:3]\\\\n[   2.00    5.00 ]\\\\n, :rows [#RealBlockVector[double, n:2, offset: 0, stride:3]\\\\n[   1.00    4.00 ]\\\\n #RealBlockVector[double, n:2, offset: 1, stride:3]\\\\n[   2.00    5.00 ]\\\\n #RealBlockVector[double, n:2, offset: 2, stride:3]\\\\n[   3.00    6.00 ]\\\\n]}\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Defines a rotation matrix in 2D\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn rotate [d]\\n  (dge 2 2 [(cos d) (sin d) (- (sin d)) (cos d)]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.neanderthal/rotate\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Defines a homothety matrix in 2D\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn scale [alpha]\\n  (scal alpha (dge 2 2 [1 0 0 1])))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"linalg.neanderthal/scale\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Some function to manipulate the vectors\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" $x + x$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(cc (axpy x x))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"#RealBlockVector[double, n:3, offset: 0, stride:1]\\\\n[   2.00    4.00    6.00 ]\\\\n\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Same thing as above\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(cc (axpy 1 x 1 x))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"#RealBlockVector[double, n:3, offset: 0, stride:1]\\\\n[   2.00    4.00    6.00 ]\\\\n\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" $-x$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(cc (scal -1 x))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"#RealBlockVector[double, n:3, offset: 0, stride:1]\\\\n[  -1.00   -2.00   -3.00 ]\\\\n\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Addition and scaling of vectors in $V=\\\\mathbb{R}^2$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(clerk/plotly\\n (let [_ 1\\n       alpha 0.5\\n       x (unn/dv [-2 2])\\n       ax (unc/ax alpha x)\\n       y (unn/dv [1 1])\\n       x+y (unc/xpy x y)]\\n   {:data [{:x [0 (unc/entry x 0)]\\n            :y [0 (unc/entry x 1)]\\n            :name :x}\\n           {:x [0 (unc/entry y 0)]\\n            :y [0 (unc/entry y 1)]\\n            :name :y}\\n           {:x [(unc/entry y 0) (unc/entry x+y 0)]\\n            :y [(unc/entry y 1) (unc/entry x+y 1)]\\n            :name :x'}\\n           {:x [0 (unc/entry ax 0)]\\n            :y [0 (unc/entry ax 1)]\\n            :name :alpha*x}\\n           {:x [0 (unc/entry x+y 0)]\\n            :y [0 (unc/entry x+y 1)]\\n            :name :x+y}]}))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:x [0 -2.0], :y [0 2.0], :name :x} {:x [0 1.0], :y [0 1.0], :name :y} {:x [1.0 -1.0], :y [1.0 3.0], :name :x'} {:x [0 -1.0], :y [0 1.0], :name :alpha*x} {:x [0 -1.0], :y [0 3.0], :name :x+y}]}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Example of vector subspace\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A view on the space $V=\\\\mathbb{R}^3$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(clerk/plotly\\n (let [_ 1]\\n   {:data [{:z [0]\\n            :x [0]\\n            :y [0]\\n            :type :mesh3d}]\\n    :layout {:scene {:aspectmode :cube}\\n             :xaxis {:range [-2 2]}\\n             :yaxis {:range [-2 2]}}}))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:z [0], :x [0], :y [0], :type :mesh3d}], :layout {:scene {:aspectmode :cube}, :xaxis {:range [-2 2]}, :yaxis {:range [-2 2]}}}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Example of vector subspace of $V=\\\\mathbb{R}^3$\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(clerk/plotly\\n (let [_ 1\\n       x [1 0 1]\\n       y [0 1 1]\\n       args (unc/trans (unn/dge [x y]))\\n       grid (unc/trans\\n             (dge 2 100\\n                  (for [i (range -5 5) j (range -5 5)]\\n                    [i j])))\\n       z (unc/mm grid args)\\n       z2 (unc/mm grid (unc/trans (unn/dge [[1 1 0] [0 -1 1]])))]\\n   {:data [{:z (->vec (unc/col z 2))\\n            :x (->vec (unc/col z 0))\\n            :y (->vec (unc/col z 1))\\n            :type :mesh3d}\\n           {:z (->vec (unc/col z2 2))\\n            :x (->vec (unc/col z2 0))\\n            :y (->vec (unc/col z2 1))\\n            :type :mesh3d}]\\n    :layout {:scene {:aspectmode :cube}\\n             :xaxis {:range [-2 2]}\\n             :yaxis {:range [-2 2]}}}))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:z [-10.0 -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0 -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 5.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 5.0 6.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 -1.0 0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0], :x [-5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 3.0 3.0 3.0 3.0 3.0 3.0 3.0 3.0 3.0 3.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0], :y [-5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0], :type :mesh3d} {:z [-5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0 -5.0 -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0], :x [-5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -5.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -4.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -3.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 3.0 3.0 3.0 3.0 3.0 3.0 3.0 3.0 3.0 3.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0 4.0], :y [0.0 -1.0 -2.0 -3.0 -4.0 -5.0 -6.0 -7.0 -8.0 -9.0 1.0 0.0 -1.0 -2.0 -3.0 -4.0 -5.0 -6.0 -7.0 -8.0 2.0 1.0 0.0 -1.0 -2.0 -3.0 -4.0 -5.0 -6.0 -7.0 3.0 2.0 1.0 0.0 -1.0 -2.0 -3.0 -4.0 -5.0 -6.0 4.0 3.0 2.0 1.0 0.0 -1.0 -2.0 -3.0 -4.0 -5.0 5.0 4.0 3.0 2.0 1.0 0.0 -1.0 -2.0 -3.0 -4.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0 -1.0 -2.0 -3.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0 -1.0 -2.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0 -1.0 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 0.0], :type :mesh3d}], :layout {:scene {:aspectmode :cube}, :xaxis {:range [-2 2]}, :yaxis {:range [-2 2]}}}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Example of Rotation (isometric transformation)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(clerk/plotly\\n (let [v (rand-vec 2)\\n       w (unc/mv (rotate (/ Math/PI 2)) v)]\\n   (->plotly v w)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:x [0 0.35793808450964365], :y [0 0.9337453226964874], :name :original} {:x [0 -0.9337453226964874], :y [0 0.3579380845096437]}], :layout {:width 820, :height 600, :legend {:orientation :h}}}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(clerk/plotly\\n (let [_ 3 ;; otherwise not rendered\\n       v (rand-vec 2)\\n       w (unc/mv (rotate (/ Math/PI 2)) v)]\\n   (->plotly v w)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:x [0 0.9964611974329851], :y [0 0.08405404220155854], :name :original} {:x [0 -0.08405404220155849], :y [0 0.9964611974329851]}], :layout {:width 820, :height 600, :legend {:orientation :h}}}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(clerk/plotly\\n (let [_ 2\\n       v (rand-vec 2)\\n       w (unc/mv (rotate Math/PI) v)]\\n   (->plotly v w)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:x [0 0.1664864174157841], :y [0 0.9860437479219962], :name :original} {:x [0 -0.1664864174157842], :y [0 -0.9860437479219962]}], :layout {:width 820, :height 600, :legend {:orientation :h}}}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(clerk/plotly\\n (let [_ 1\\n       v (rand-vec 2)\\n       w (unc/mv (rotate (/ Math/PI 3)) v)]\\n   (->plotly v w)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:x [0 0.7468746422234789], :y [0 0.6649648628337821], :name :original} {:x [0 -0.2024391427263505], :y [0 0.9792948450248375]}], :layout {:width 820, :height 600, :legend {:orientation :h}}}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Example of non commutativity of the linear maps\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def T (dge 2 2 [1 2 0 2]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #RealGEMatrix[double, mxn:2x2, layout:column, offset:0]\\n   ▥       ↓       ↓       ┓    \\n   →       1.00    0.00         \\n   →       2.00    2.00         \\n   ┗                       ┛    \\n, :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def U (dge 2 2 [1 0 1 1]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #RealGEMatrix[double, mxn:2x2, layout:column, offset:0]\\n   ▥       ↓       ↓       ┓    \\n   →       1.00    1.00         \\n   →       0.00    1.00         \\n   ┗                       ┛    \\n, :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(clerk/plotly\\n (let [_ 4\\n       v (rand-vec 2)]\\n   (->plotly\\n    v\\n    (unc/mv (mm U T) v)\\n    (unc/mv (mm T U) v))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:x [0 0.11755382626792288], :y [0 0.993066512339315], :name :original} {:x [0 2.3387945034823985], :y [0 2.2212406772144755]} {:x [0 1.1106203386072377], :y [0 4.207373701893106]}], :layout {:width 820, :height 600, :legend {:orientation :h}}}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Example of eigenvalues and eigen vectors\\n The matrix $T$ is given by\\n $$ T = \\\\begin{bmatrix} 1 & 0 \\\\\\\\ 0 & -1 \\\\end{bmatrix} $$\\n This only flip the sign of the second element of the vector With a bit of\\n intuition we see that $e_1 = \\\\begin{bmatrix} 1 & 0 \\\\end{bmatrix}$ and\\n $e_2 = \\\\begin{bmatrix} 0 & 1 \\\\end{bmatrix}$ are eigenvectors with the\\n eigenvalues $1$ and $-1$.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(clerk/plotly\\n (let [_ 0\\n       T (dge 2 2 [1 0 0 -1])\\n       v (dv [1 1])\\n       w (unc/mv T v)\\n       e1 (dv [1 0])\\n       e2 (dv [0 1])]\\n   (->plotly v w e1 (unc/mv T e1) e2 (unc/mv T e2))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value {:data [{:x [0 1.0], :y [0 1.0], :name :original} {:x [0 1.0], :y [0 -1.0]} {:x [0 1.0], :y [0 0.0]} {:x [0 1.0], :y [0 0.0]} {:x [0 0.0], :y [0 1.0]} {:x [0 0.0], :y [0 -1.0]}], :layout {:width 820, :height 600, :legend {:orientation :h}}}, :nextjournal/viewer :plotly}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Here is how you can explore the eigenvalue API\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(cc\\n (let [_    0\\n       T    (unc/mm (rotate (/ Math/PI 2)) (dge 2 2 [1 0 0 -1]))\\n       T'   (unc/copy T)\\n       v    (dv [1 1])\\n       w    (unc/mv T v)\\n       evec (dge 2 2)\\n       vr   (dge 2 2)\\n       vl   (dge 2 2)\\n       _    (unl/ev! T' evec vr vl)]\\n   {:t T\\n    :t' T'\\n    :e evec\\n    :vr vr\\n    :vl vl}))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"{:t #RealGEMatrix[double, mxn:2x2, layout:column, offset:0]\\\\n   ▥       ↓       ↓       ┓    \\\\n   →       0.00    1.00         \\\\n   →       1.00   -0.00         \\\\n   ┗                       ┛    \\\\n, :t' #RealGEMatrix[double, mxn:2x2, layout:column, offset:0]\\\\n   ▥       ↓       ↓       ┓    \\\\n   →       1.00    0.00         \\\\n   →       0.00   -1.00         \\\\n   ┗                       ┛    \\\\n, :e #RealGEMatrix[double, mxn:2x2, layout:column, offset:0]\\\\n   ▥       ↓       ↓       ┓    \\\\n   →       1.00    0.00         \\\\n   →      -1.00    0.00         \\\\n   ┗                       ┛    \\\\n, :vr #RealGEMatrix[double, mxn:2x2, layout:column, offset:0]\\\\n   ▥       ↓       ↓       ┓    \\\\n   →       0.71   -0.71         \\\\n   →       0.71    0.71         \\\\n   ┗                       ┛    \\\\n, :vl #RealGEMatrix[double, mxn:2x2, layout:column, offset:0]\\\\n   ▥       ↓       ↓       ┓    \\\\n   →       0.71   -0.71         \\\\n   →       0.71    0.71         \\\\n   ┗                       ┛    \\\\n}\\\\n\\\", :nextjournal/viewer :code}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(comment\\n\\n  (unc/nrm2 (dv [0.70705 0.70705]))\\n  (dge 2 2 [2 0 0 -3])\\n\\n  (cc (unc/mmt z))\\n  (cc (unc/view-ge z 2))\\n  (cc (unc/view-ge (unc/mmt z) 3))\\n  (clerk/show! \\\"src/linalg/neanderthal.clj\\\")\\n\\n  )\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :linalg.neanderthal}}}")
app.init(docs)
</script></body></html>